/*
1. 继承:
	继承分为公有(public)继承,保护(protected)继承,私有(private)继承, 常用的就是公有继承, 在子类继承父类的成员后, 主要根据父类成员本身的权限(原有继承方式)和现有继承方式取最小; 公有不变; 公有变保护; 公有保护全变私有; 不管怎样继承, 父类的私有成员对子类不可见, 但是在子类存在;
	切片是子类向父类的赋值(把子类的指针,对象,引用赋值给父类对应的指针..),不是转换, 父类对象不能赋给子类对象, 父类指针/引用可以通过强制转换赋给子类指针/引用, 不安全,可能导致访问不到子类新定义的成员, 访问的成员变量找不到或者越界了. 尽量不要把父类类型转换为子类, 在多态情况下,用动态转化是安全的
	继承当中子类的成员函数主要是调用父类的成员函数, 不同的成员函数调用逻辑不同:
	子类构造函数会自动调用父类的构造函数(在初始化列表调), 不写的话 会调用父类默认构造, 写了的话,调用指定构造函数; 主要用来完成父类成员的初始化, 父类成员不能直接写在子类构造的初始化列表中, 必须通过父类的构造函数完成初始化, 子类的列表中只能初始化自己新定义的成员变量. 
	如果不写子类的拷贝构造,默认拷贝构造会自动调用父类的拷贝构造完成父类成员的拷贝构造(通过初始化列表), 如果显式定义了子类的拷贝构造, 那他的默认行为就会调父类的默认构造(而不是拷贝构造了),除非显式指定调用父类的拷贝构造才会调父类的拷贝构造; 
	默认的赋值运算符也会调用父类的赋值运算符,如果显式定义了,那就不会自动去调用父类的赋值运算符 要想调用父类的赋值运算符,就要显示调用, 需要加上父类作用域(这两成员函数属于函数隐藏) 才能把父类的赋值运算符调用, 否则就一直调用的是自己的赋值运算符
	不写父类的析构函数, 不管写不写, 编译器都会调用父类析构一次, 如果写了, 就会导致父类中的析构函数被调用两次, 导致父类资源被释放两次, 所以在子类的析构中不能显示去调用父类的析构, (一是默认析构会调父类析构, 二是两析构函数构成同名隐藏), 
	继承中友元关系也是不能被继承下来的, 一个父类是另一个的友元类, 不能说明子类也是他的友元类,
	继承中的静态成员(static)属于全局中的静态成员, 不管是直接继承,还是间接继承, 只要在父类中定义了静态成员, 那么父类对象,子类对象访问的都是同一个静态成员,是整个继承体系中的静态成员
	菱形继承是多个父类继承同一个基类, 缺点:导致同一份数据会有冗余(基类中的数据会被存两次); 数据会有二义性,编译器不知该使用哪个成员;
	虚拟继承(虚基表, 虚基表指针):主要用再有继承自多个基类的父类当中, 去虚拟继承基类,保证共同基类在整个继承体系的最下面的子类对象中只会保留一份,一般保留在对象模型的最下面; 想要访问公共的成员(做一个切片操作), 把子类对象切给父类对象,如何去拿父类的对象,就要通过虚基表指针先找虚基表,再在虚基表中找偏移量, 在从当前的父类的起始位置偏移拿到公共的成员完成切片操作, 为了去解决菱形继承的问题, 一般都写单继承, 很少写多继承; 
2. 多态
  多态就是同一种行为不同的表现形态结果, 主要表现在不同的子对象在执行父类的同一个行为时,表现出不同的表现形式; 想要实现多态的话, 需要在继承的前提下,函数必须为虚函数, 虚函数要完成重写或覆盖; 通过对象的指针或引用调用虚函数, 通过父类的指针和引用来指向对象, 产生多态
  函数重载:同一个作用域下 函数名相同.参数不同的函数 构成函数重载
  函数隐藏: 存在于父类和子类作用域当中(继承作用域当中),属于不同的作用域, 只要函数名相同 就会构成函数隐藏,
  函数重写: 如果函数是个虚函数, 还完成了虚函数的重写 则构成函数覆盖. 在继承当中 只要函数名相同 至少会构成函数隐藏
3. 关联容器
4. C++11
5. 异常
6. 智能指针
7. 特殊类设计
8. C++类型转换
9. 空间配置器
*/