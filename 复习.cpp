/*
1. 继承:
	继承分为公有(public)继承,保护(protected)继承,私有(private)继承, 常用的就是公有继承, 在子类继承父类的成员后, 主要根据父类成员本身的权限(原有继承方式)和现有继承方式取最小; 公有不变; 公有变保护; 公有保护全变私有; 不管怎样继承, 父类的私有成员对子类不可见, 但是在子类存在;
	切片是子类向父类的赋值(把子类的指针,对象,引用赋值给父类对应的指针..),不是转换, 父类对象不能赋给子类对象, 父类指针/引用可以通过强制转换赋给子类指针/引用, 不安全,可能导致访问不到子类新定义的成员, 访问的成员变量找不到或者越界了. 尽量不要把父类类型转换为子类, 在多态情况下,用动态转化是安全的
	继承当中子类的成员函数主要是调用父类的成员函数, 不同的成员函数调用逻辑不同:
	子类构造函数会自动调用父类的构造函数(在初始化列表调), 不写的话 会调用父类默认构造, 写了的话,调用指定构造函数; 主要用来完成父类成员的初始化, 父类成员不能直接写在子类构造的初始化列表中, 必须通过父类的构造函数完成初始化, 子类的列表中只能初始化自己新定义的成员变量. 
	如果不写子类的拷贝构造,默认拷贝构造会自动调用父类的拷贝构造完成父类成员的拷贝构造(通过初始化列表), 如果显式定义了子类的拷贝构造, 那他的默认行为就会调父类的默认构造(而不是拷贝构造了),除非显式指定调用父类的拷贝构造才会调父类的拷贝构造; 
	默认的赋值运算符也会调用父类的赋值运算符,如果显式定义了,那就不会自动去调用父类的赋值运算符 要想调用父类的赋值运算符,就要显示调用, 需要加上父类作用域(这两成员函数属于函数隐藏) 才能把父类的赋值运算符调用, 否则就一直调用的是自己的赋值运算符
	不写父类的析构函数, 不管写不写, 编译器都会调用父类析构一次, 如果写了, 就会导致父类中的析构函数被调用两次, 导致父类资源被释放两次, 所以在子类的析构中不能显示去调用父类的析构, (一是默认析构会调父类析构, 二是两析构函数构成同名隐藏), 
	继承中友元关系也是不能被继承下来的, 一个父类是另一个的友元类, 不能说明子类也是他的友元类,
	继承中的静态成员(static)属于全局中的静态成员, 不管是直接继承,还是间接继承, 只要在父类中定义了静态成员, 那么父类对象,子类对象访问的都是同一个静态成员,是整个继承体系中的静态成员
	菱形继承是多个父类继承同一个基类, 缺点:导致同一份数据会有冗余(基类中的数据会被存两次); 数据会有二义性,编译器不知该使用哪个成员;
	虚拟继承(虚基表, 虚基表指针):主要用再有继承自多个基类的父类当中, 去虚拟继承基类,保证共同基类在整个继承体系的最下面的子类对象中只会保留一份,一般保留在对象模型的最下面; 想要访问公共的成员(做一个切片操作), 把子类对象切给父类对象,如何去拿父类的对象,就要通过虚基表指针先找虚基表,再在虚基表中找偏移量, 在从当前的父类的起始位置偏移拿到公共的成员完成切片操作, 为了去解决菱形继承的问题, 一般都写单继承, 很少写多继承; 
2. 多态
  多态就是同一种行为不同的表现形态结果, 主要表现在不同的子对象在执行父类当中定义的同一个行为时,表现出不同的表现形式; 想要实现多态的话, 需要在继承的前提下,函数必须为虚函数, 虚函数要完成重写或覆盖; 通过对象的指针或引用调用虚函数, 通过父类的指针和引用来指向对象, 产生多态
  函数重载: 同一个作用域下 函数名相同.参数不同的函数 构成函数重载
  函数隐藏: 存在于父类和子类作用域当中(继承当中),属于不同的作用域, 只要函数名相同 就会构成函数隐藏,
  函数重写: 如果函数是个虚函数, 还完成了虚函数的重写 则构成函数覆盖或重写. 在继承当中 只要函数名相同 至少会构成函数隐藏；如果符合严格的函数重写的条件 那就构成函数重写（函数名，参数列表，返回值必须完全一样）
  协变：返回值可以不同（但是返回值必须构成继承关系下的指针或引用类型），这样才能构成函数重载
  抽象类： 接口继承的体现; 定义抽象类主要是为了重写抽象类当中的虚函数，在抽象类当中很少会定义虚函数的函数体，一般会把抽象类中的虚函数写成纯虚函数（只有函数接口，没有函数体，让函数等于0），包括了纯虚函数的类就是一个抽象类（成员不完整，不能进行实例化，主要是为了完成多态的语法，完成重写抽象类的虚函数，继承的就是函数的接口，）在子类当中必须重写虚函数，否则子类也是一抽象类 也不能实例化。
	C++11当中会加override声明,让子类的虚函数强制重写父类的虚函数,如果没有重写父类虚函数,则语法不过. 一定要写出构成重写的虚函数,实现多态行为. 
	同一个指针指向不同的对象时会执行不同的行为, 原因在于虚函数完成了重写, 就会在虚表当中存放不同的函数地址, 最终由于指针指向对象不同,所对应的虚表不同,才会产生不同的指令. 虚表指针主要是为了让我们找到虚表
	虚表指针是存放在对象当中,虚表不在对象当中存在, 同一个类的对象 虚表一样(所以没有必要给每一个对象都存放一个虚表, 只要把虚表放在公共地方,同类对象访问同一个虚表, 只在对象当中存放虚表指针, 虚表指针一般是放在对象头部的 4 个字节(32位程序)或者 8 个字节(64位程序); 
	具体实现多态是通过父类指针他所指向的对象先去对象的头部拿到虚表指针,再通过虚表指针去访问虚表, 再从虚表当中找到需要执行的函数地址, 再去执行对应的函数, 如果是不同类型的对象,只要完成了虚函数的重写, 在虚表当中父类的虚函数指针就会被子类重写的虚函数指针覆盖掉, 这样就会在实际的运行中产生不同对象多态的行为.    虚表当中并不是存放函数的代码, 只存放函数的指针, 函数的代码是放在代码段中的, 单继承和多继承虚表也是有差异的, 如果单继承: 子类会继承父类的虚表,然后对于重写的虚函数会直接把虚表当中对应的函数指针覆盖成子类重写的函数指针; 如果是多继承 在子类当中虚表不只有一个,虚表的个数是和直接父类的个数一样的, 在虚表当中如果子类新定义了虚函数, 会按照声明的顺序把新定义的虚函数的地址依次存放到虚表当中去, 如果是多继承会放在第一个直接父类的虚表当中去,虚表是以指针空值来结束的, 通过指针空值来判断虚表是否访问完成.
3. 关联容器
	二叉搜索树: 不会保证树一定平衡(平衡是根据树的相关操作来看的,譬如插入的顺序) 二叉搜索树搜索性能logN;  
	删除: 如果删除的是叶子结点, 则直接删除, 将父结点的指向置为空, 删除的为非叶子结点(看删除的结点是否有完整的孩子节点,如果只有一边,则需要判断是左孩子存在还是右孩子存在,)如果只有一边孩子,需要把当前接地那删掉,把孩子结点做相应的链接, 如果左右孩子节点都存在, 则需要找一个结点, 让他来作为被删除结点取代的位置(根一般是取最左结点,以被删除结点为根的最左结点或者最右结点来作为新子树的根, 当找到最左结点或者最右节点, 把其值拷贝到被删除结点当中, 再去把最左或最右结点删掉. (此时又要继续看最左结点或最右结点是否为有一边孩子还是两个孩子, 继续找到替代结点) 最左结点一般选右子树的最左结点,最右结点一般是左子树的最右结点, (因为左子树的最右结点时大于左子树上的所有结点 但又小于右子树的所有结点, 可以作为当前树的根; 同样右子树的最左结点也是小于右子树的其他节点, 又大于左子树的所有结点, 所以也可以作为新的根)
	AVL树(高度平衡树): 通过平衡因子来控制平衡性, 没插入一个结点都需要进行平衡因子的更新, 在更新的过程中, 还需要判断需不需要旋转, 如果更新到某一个结点的平衡因子为0,(当前这个位置的高度并未发生变化, 不影响树的平衡性, 如果平衡因子更新之后绝对值为1(正1或负一),则说明当前位置某一边高度发生了变化, 高度发生变化就会影响整个树 的平衡性, 需要继续向上更新, 当更新之后平衡因子绝对值为2,就说明当前节点左右节点的高度差是2, 在AVL中是不允许存在高度差为2 的树的,这时就需要旋转将左右子树的高度差降下来,重新达到平衡,
			
	红黑树: 
	这三个树都属于二叉搜索树, 但是AVL和红黑树都是平衡的二叉搜索树, 
	哈希表:
4. C++11
5. 异常
6. 智能指针
7. 特殊类设计
8. C++类型转换
9. 空间配置器
*/